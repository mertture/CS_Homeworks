# -*- coding: utf-8 -*-
"""mertture_26800_HW1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ca3_Ss_ZXvfyhUTCEV9GBVubJamx-9yx
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# MERT TÃœRE 26800 CS48007 HW1
"""# PART 1"""

walking_file_name = "walking.csv"

walking = pd.read_csv(walking_file_name, delimiter=";")

# for calculating acceleration magnitude
data_magnitude = walking.apply(lambda x: np.sqrt(x["AccelerationX"]**2 + x["AccelerationY"]**2 + x["AccelerationZ"]**2), axis=1).to_numpy()

AccelerationX = walking["AccelerationX"]
AccelerationY = walking["AccelerationY"]
AccelerationZ = walking["AccelerationZ"]
accelerationMagnitude = data_magnitude
walking["accelerationMagnitude"] = accelerationMagnitude

timestamp = walking.Timestamp - walking.Timestamp.min()
walking["Timestamp"] = timestamp

''' UNCOMMENT TO PLOT'''
# plt.figure(figsize=(24, 6))

# plt.plot(timestamp, AccelerationX, label="X")

# plt.plot(timestamp, AccelerationY, label="Y")

# plt.plot(timestamp, AccelerationZ, label="Z")

# # FROM THE WALKING DATA
# # We can see that there are obvious stable peaks but a bit complicated because it is not filtered yet, 
# # From the obviouseness of the peaks and plot, we can say that this is walking
# plt.legend()
# plt.xlabel("Time (sec)")
# plt.ylabel("Acceleration (m^2/s)")

running_file_name = "running.csv"

running = pd.read_csv(running_file_name, delimiter=";")

# for calculating acceleration magnitude
data_magnitude = running.apply(lambda x: np.sqrt(x["AccelerationX"]**2 + x["AccelerationY"]**2 + x["AccelerationZ"]**2), axis=1).to_numpy()

AccelerationX = running["AccelerationX"]
AccelerationY = running["AccelerationY"]
AccelerationZ = running["AccelerationZ"]
accelerationMagnitude = data_magnitude
running["accelerationMagnitude"] = accelerationMagnitude

timestamp = running.Timestamp - running.Timestamp.min()
running["Timestamp"] = timestamp

''' UNCOMMENT TO PLOT'''

# plt.figure(figsize=(24, 6))

# plt.plot(timestamp, AccelerationX, label="X")

# plt.plot(timestamp, AccelerationY, label="Y")

# plt.plot(timestamp, AccelerationZ, label="Z")

# # FROM THE RUNNING DATA
# # We can see that there are obvious a bit higher peaks than running
# # because running is more unstable and moving than walking. We can say that with this much sharper peaks, this is running and we can use that
# plt.legend()
# plt.xlabel("Time (sec)")
# plt.ylabel("Acceleration (m^2/s)")

sitting_file_name = "sitting.csv"

sitting = pd.read_csv(sitting_file_name, delimiter=";")

# for calculating acceleration magnitude
data_magnitude = sitting.apply(lambda x: np.sqrt(x["AccelerationX"]**2 + x["AccelerationY"]**2 + x["AccelerationZ"]**2), axis=1).to_numpy()

AccelerationX = sitting["AccelerationX"]
AccelerationY = sitting["AccelerationY"]
AccelerationZ = sitting["AccelerationZ"]
accelerationMagnitude = data_magnitude
sitting["accelerationMagnitude"] = accelerationMagnitude

timestamp = sitting.Timestamp - sitting.Timestamp.min()
sitting["Timestamp"] = timestamp

''' UNCOMMENT TO PLOT'''

# plt.figure(figsize=(24, 6))

# plt.plot(timestamp, AccelerationX, label="X")

# plt.plot(timestamp, AccelerationY, label="Y")

# plt.plot(timestamp, AccelerationZ, label="Z")


# # FROM THE SITTING DATA
# # We can see that this plot is very stable and not much peaks. Current peaks are little movements on the chair but they should be gone after appropriate filtering.
# # Therefore, we can say that there are no peaks so steps and not use this.

# plt.legend()
# plt.xlabel("Time (sec)")
# plt.ylabel("Acceleration (m^2/s)")

standing_file_name = "standing.csv"

standing = pd.read_csv(standing_file_name, delimiter=";")

# for calculating acceleration magnitude
data_magnitude = standing.apply(lambda x: np.sqrt(x["AccelerationX"]**2 + x["AccelerationY"]**2 + x["AccelerationZ"]**2), axis=1).to_numpy()

AccelerationX = standing["AccelerationX"]
AccelerationY = standing["AccelerationY"]
AccelerationZ = standing["AccelerationZ"]
accelerationMagnitude = data_magnitude
standing["accelerationMagnitude"] = accelerationMagnitude

timestamp = standing.Timestamp - standing.Timestamp.min()
standing["Timestamp"] = timestamp

''' UNCOMMENT TO PLOT'''

# plt.figure(figsize=(24, 6))

# plt.plot(timestamp, AccelerationX, label="X")

# plt.plot(timestamp, AccelerationY, label="Y")

# plt.plot(timestamp, AccelerationZ, label="Z")

# # FROM THE STANDING DATA
# # We can see that this is as stable as sitting with some little movements which are again due to standing and they should be gone with appropriate filtering
# # Sitting and standing should be pretty similar and we cannot use both for step counting.

# # MAGNITUDE FEATURE IS CALCULATED AND USED FOR ALL SITUATIONS -> magnitude is a great feature extraction because while walking, 
# # running we can change our direction but with magnitude we take all to account
# plt.legend()
# plt.xlabel("Time (sec)")
# plt.ylabel("Acceleration (m^2/s)")

"""# PART 2"""

file_name = input("Enter your file name: ")

data = pd.read_csv(file_name, delimiter=";")

print(data.head())

print(data.dtypes)

# for calculating acceleration magnitude
data_magnitude = data.apply(lambda x: np.sqrt(x["AccelerationX"]**2 + x["AccelerationY"]**2 + x["AccelerationZ"]**2), axis=1).to_numpy()

AccelerationX = data["AccelerationX"]
AccelerationY = data["AccelerationY"]
AccelerationZ = data["AccelerationZ"]
accelerationMagnitude = data_magnitude
data["accelerationMagnitude"] = accelerationMagnitude

timestamp = data.Timestamp - data.Timestamp.min()
data["Timestamp"] = timestamp

plt.figure(figsize=(24, 6))

plt.plot(timestamp, AccelerationX, label="X")

plt.plot(timestamp, AccelerationY, label="Y")

plt.plot(timestamp, AccelerationZ, label="Z")


plt.legend()
plt.xlabel("Time (sec)")
plt.ylabel("Acceleration (m^2/s)")

plt.figure(figsize=(24, 6))

plt.plot(timestamp, accelerationMagnitude, label="Magnitude")

plt.legend()
plt.xlabel("Time (sec)")
plt.ylabel("Acceleration (m^2/s)")


def LPF(fs):
    N = 25
    n = np.arange(N)
    fc = 0.5 / fs # gave cut off 0.5Hz
    h = (0.42-0.5*np.cos(2*np.pi*n/(N-1))+0.8*np.cos(4*np.pi*n/(N-1))) * np.sinc(2*fc*(n-(N-1)/2))
    # normalize and return h
    h = h/sum(h)
    return h

# formula is taken from the lecture slides (discrete convolution)
def convolve_signal(data, filter):
    filtered_data = []
    for i in range(len(data) + len(filter) - 1):
        y = 0
        for j in range(len(filter)):
            if (0 <= i-j < len(data)):
                y += data[i-j] * filter[j]
        filtered_data.append(y)
    # ceil filter size / 2 for first and last is not important. It is emitted
    return filtered_data[len(filter)// 2 : (len(filtered_data) - (len(filter)//2))]

def peak_finder(filtered_signal, map, filtered_timestamp):
  starting_point = 1
  peaks = 0
  for i in range(starting_point, len(filtered_signal)-1):
 
    # finding the local maxima by checking direct neighbours
    if (filtered_signal[i-1] < filtered_signal[i] and filtered_signal[i+1] < filtered_signal[i] and filtered_timestamp[i] not in map.keys()):
      peaks += 1
      map[filtered_timestamp[i]] = True
     
  return peaks


# Filtering usage
sampling_frequency = data.shape[0] / (data["Timestamp"].max() - data["Timestamp"].min())
filter = LPF(sampling_frequency)
filtered_data = convolve_signal(data["accelerationMagnitude"].to_numpy(), filter)

map = {}
peaks = 0
window_size = 21
#Window size can be taken as input on the below line
#window_size = int(input("Window size: "))
print("Window size: ", window_size)

for i in range(len(data)-window_size+1):

  peaks += peak_finder(filtered_data, map, data["Timestamp"].to_numpy())

print("Step count: ", peaks)

plt.figure(figsize=(24, 6))
plt.plot(data["Timestamp"], filtered_data, label="Magnitude")


plt.xlabel("Time (sec)")
plt.ylabel("Acceleration Magnitude after Filtering (m^2/s)")
plt.legend()
plt.show()
# plot is for the all signal data's filtered result